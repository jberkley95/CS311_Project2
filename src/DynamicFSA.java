import java.util.Arrays;

/**
 * @author John Berkley
 * CPP Class: CS 311
 * Date Created: Nov 07, 2017
 */
public class DynamicFSA {
    private final int MAX_TRANSITION = 10000;
    private int[] initialSymbolTable;
    private char[] nextSymbolTable;
    private int[] nextSymbolShiftTable;
    private int currSymTableSize;
    private int ptr;


    /**
     * Constructor initializes all tables. Set initialSymbol table to 54 and others
     * to the MAX_TRANSITION size, along with filling any tables containing indexes with -1
     */
    public DynamicFSA() {
        initialSymbolTable = new int[54];
        nextSymbolTable = new char[MAX_TRANSITION];
        nextSymbolShiftTable = new int[MAX_TRANSITION];
        currSymTableSize = 0;
        ptr = -1;
        Arrays.fill(initialSymbolTable, -1);
        Arrays.fill(nextSymbolShiftTable, -1);
    }

    /**
     * Reads in a line to the Dynamic FSA and adds if the current word doesn't exist, or modify
     * if it was seen once before, then displays data in console, stripped of all extraneous characters
     *
     * @param newInput line to be processed by the Dynamic FSA
     * @param isKeyword true if processing the keyword file, and false otherwise
     */
    public void processLine(String newInput, boolean isKeyword) {
        //regex to strip all extraneous characters from the line
        //has problem with "}" for some reason, leaves an empty string instead of being stripped
        newInput = newInput.replaceAll("[^a-zA-Z0-9_$][0-9]*", " ").trim();
        String[] line = newInput.split("\\s+");

        //iterate across all words in line
        for (String aLine : line) {
            //handle empty string problem generated by "}"
            if (line[0].equals("")) break;

            //display the word before processing and displaying end character
            if (!isKeyword) {
                System.out.print(aLine);
            }

            //algorithm provided in assignment documentation
            int currChar = 0;
            char currSymbol = aLine.charAt(currChar);
            int currSymbolIndex = getIndex(currSymbol);
            ptr = initialSymbolTable[currSymbolIndex];
            if (ptr == -1) {
                initialSymbolTable[currSymbolIndex] = currSymTableSize;
                createNew(aLine.substring(currChar + 1, aLine.length()), isKeyword);
            } else {
                if (aLine.length() > 1) {
                    currSymbol = aLine.charAt(++currChar);
                }
                boolean exit = false;
                while (!exit) {
                    if (nextSymbolTable[ptr] == currSymbol) {
                        if (nextSymbolTable[ptr + 1] != '*' && nextSymbolTable[ptr + 1] != '?' && nextSymbolTable[ptr + 1] != '@') {
                            ptr++;
                            if (currChar + 1 < aLine.length()) {
                                currSymbol = aLine.charAt(++currChar);
                            }
                        } else {
                            if (!isKeyword) {
                                if (nextSymbolTable[ptr + 1] == '?') {
                                    nextSymbolTable[ptr + 1] = '@';
                                }
                                System.out.print(nextSymbolTable[ptr + 1] + " ");
                            }
                            exit = true;
                        }
                    } else {
                        if (nextSymbolShiftTable[ptr] != -1) {
                            ptr = nextSymbolShiftTable[ptr];
                        } else {
                            nextSymbolShiftTable[ptr] = currSymTableSize;
                            createNew(aLine.substring(currChar, aLine.length()), isKeyword);
                            exit = true;
                        }
                    }

                }
            }
        }
    }

    /**
     * displayTables prints out switch and next tables as specified in assignment documentation
     */
    public void displayTables() {
        //display switch table
        int ascii = 65;
        int index = 0;
        System.out.printf("%7s", "");
        for (int i = 0; i < 20; i++) {
            System.out.printf("%4c", ascii);
            ascii++;
        }
        System.out.println();
        System.out.printf("%7s", "switch:");
        for (int i = 0; i < 20; i++) {
            System.out.printf("%4d", initialSymbolTable[index++]);
        }
        System.out.println("\n");
        System.out.printf("%7s", "");
        for (int i = 0; i < 20; i++) {
            if (ascii == 91) {ascii = 97;}
            System.out.printf("%4c", ascii);
            ascii++;
        }
        System.out.println();
        System.out.printf("%7s", "switch:");
        for (int i = 0; i < 20; i++) {
            System.out.printf("%4d", initialSymbolTable[index++]);
        }
        System.out.println("\n");
        System.out.printf("%7s", "");
        for (int i = 0; i < 14; i++) {
            if (ascii == 96) {ascii = 36;}
            if (ascii == 123) {ascii = 95;}
            System.out.printf("%4c", ascii);
            ascii++;
        }
        System.out.println();
        System.out.printf("%7s", "switch:");
        for (int i = 0; i < 14; i++) {
            System.out.printf("%4d", initialSymbolTable[index++]);
        }
        System.out.println("\n");

        //display next symbol table
        index = 0;
        int symbolIndex = 0;
        int shiftSymbolIndex = 0;
        while (true) {
            System.out.printf("%7s", "");
            for (int i = 0; i < 20; i++) {
                System.out.printf("%4d", index);
                index++;
            }
            System.out.println();
            System.out.printf("%7s", "symbol:");
            for (int i = 0; i < 20; i++) {
                System.out.printf("%4c", nextSymbolTable[symbolIndex++]);
            }
            System.out.println();
            System.out.printf("%7s", "next:");
            for (int i = 0; i < 20; i++) {
                if (nextSymbolShiftTable[shiftSymbolIndex] == -1) {
                    System.out.printf("%4s", "");
                    shiftSymbolIndex++;
                } else {
                    System.out.printf("%4d", nextSymbolShiftTable[shiftSymbolIndex++]);
                }
            }
            System.out.println("\n");

            if (index > currSymTableSize) break;
        }
    }

    /**
     * Utilized in Dynamic FSA algorithm to add proper end character to next symbol table
     * relies on isKeyword to determine if '*' or '?' should be added
     *
     * @param newInput substring containing remainder of word to be added
     * @param isKeyword true if substring is part of a keyword, false otherwise
     */
    private void createNew(String newInput, boolean isKeyword) {
        for (int i = currSymTableSize; i < newInput.length() + currSymTableSize; i++) {
            nextSymbolTable[i] = newInput.charAt(i - currSymTableSize);
        }
        if (isKeyword) {
            nextSymbolTable[currSymTableSize + newInput.length()] = '*';
        } else {
            nextSymbolTable[currSymTableSize + newInput.length()] = '?';
            System.out.print("? ");
        }

        currSymTableSize += newInput.length() + 1;
    }

    /**
     * getIndex is used when determining the index of a char in the switch table
     * processes A-Z, a-z, _, and $
     *
     * @param currSymbol to be converted to index
     * @return index that character's slot in table is located at
     */
    private int getIndex(char currSymbol) {
        if (currSymbol >= 'A' && currSymbol <= 'Z') {
            return currSymbol - 65;
        } else if (currSymbol >= 'a' && currSymbol <= 'z') {
            return currSymbol - 71;
        } else if (currSymbol == '_') {
            return 52;
        } else {
            return 53;
        }
    }
}
